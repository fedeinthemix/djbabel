from ..types import ATrack, ATransformation, AMarker, ABeatGridBPM, APlaylist
from ..utils import CLASSIC2ABBREV_KEY_MAP, CLASSIC2CAMLEOT_KEY_MAP, OPEN_KEY2MUSICAL_KEY_MAP, is_str_or_none, is_int_or_none, is_float_or_none, is_date_or_none, CLASSIC2OPEN_KEY_MAP, reindex_sdjpro_loops, s_to_ms, adjust_time, inverse_dict
from .utils import TRAKTOR_MARKERTYPE_MAP, traktor_path, location_volume_id, is_album_tag_attr, is_entry_tag_attr, is_tempo_tag_attr, is_info_tag_attr, traktor_attr_name

from dataclasses import Field, fields
from datetime import date, datetime
from functools import reduce
from math import ceil
from pathlib import Path
import xml.etree.ElementTree as ET

import uuid

#######################################################################
# Comments

# Tags and attributes are all UPPERCASE.

## Attributes, tags and sub-tag attributes of an NML ENTRY:

### Attributes
# - MODIFIED_DATE, (required), set to today
# - MODIFIED_TIME, (required), likely seconds from midnight UTC
# - AUDIO_ID, (required), audio fingerprint. Set it to "" to leave the job to Traktor.
# - TITLE, (required)
# - ARTIST, (required)
# - LOCK="1", Beatgrid lock.
# - LOCK_MODIFICATION_TIME="2025-07-09T15:13:07"

### Sub-tags and their attributes

## LOCATION, (required)
# - DIR
# - FILE
# - VOLUME, volume name, a string, on Win e.g. "C:"
# - VOLUMEID, volume serial or UUID, On Win output of 'vol $VOLUME'

## ALBUM
# - TRACK, track number
# - TITLE

## MODIFICATION_INFO
# - AUTHOR_TYPE="user"

## INFO
# - BITRATE (bps)
# - GENRE
# - LABEL
# - COVERARTID
# - KEY="1m", can use other notations than Open Key (e.g. Camleot, or Classic)
# - PLAYCOUNT
# - PLAYTIME="261"
# - PLAYTIME_FLOAT="260.858765"
# - IMPORT_DATE="2025/7/9"
# - LAST_PLAYED="2025/7/8"
# - RELEASE_DATE="2025/1/1"
# - FLAGS="76", (required), see below for the meaning. 
# - FILESIZE="11746"
# - RATING="4"
# - REMIXER=""

## TEMPO
# - BPM="126.999878", (required to retain BG), the best fit fixed grid BPM
# - BPM_QUALITY="100.000000", (required to retain BG), set to "100.0"

## LOUDNESS
# - PEAK_DB="-0.721318"
# - PERCEIVED_DB="0.000000"
# - ANALYZED_DB="-0.860893"

## MUSICAL_KEY
# - VALUE="21", (required to avoid key re-analisys)

## CUE_V2, (required type 4 to retain BG)
# - NAME, "AutoGrid" for autogenerated TYPE 4 BG, and "Beat Marker" for manual BG
# - DISPL_ORDER="0", apparently always "0"
# - TYPE="4", 4 is SPECIAL for beatgrid and uses the <GRID/> tag
# - START="52.261284" (ms)
# - LEN="0.000000" (ms)
# - REPEATS="-1", -1 is the common value and signifies that a loop repeats indefinitely
# - HOTCUE="-1", 0 based index, -1: not listed in the hot cue GUI
# - <GRID BPM="126.999878"></GRID>

### FLAGS (FBE experiments):
# Bit 0: ?
# Bit 1: ?
# Bit 2: set after any analysis
# Bit 3: set after any analysis
# Bit 4: beatgrid lock
# Bit 5: ?
# Bit 6: STEM file

###################################################################

########## Helpers ######################
def tag_attr(at: ATrack, f: Field) -> list[tuple[str,str]]:
    v = getattr(at, f.name)
    n = traktor_attr_name(f.name)
    if n is None: # skip unused parameters
        return []
    elif f.name == 'size':
        return [( n, str(round(v/1000)))] if v is not None else []
    elif f.name == 'total_time':
        return [( n, str(ceil(v))), ('PLAYTIME_FLOAT', str(v))] if v is not None else []
    elif f.name == 'locked':
        lt = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        return [( n, str(int(v))), ('LOCK_MODIFICATION_TIME', lt)]
    elif f.name == 'bit_rate':
        # We let Traktor detect the bitrate as it uses '-1' for VBR,
        # but mutagen doesn't provide the encoding mode.
        return []
    elif is_str_or_none(f.type):
        return [( n, v)] if v is not None else []
    elif is_int_or_none(f.type):
        return [( n, str(v))] if v is not None else []
    elif is_float_or_none(f.type):
        return [( n, str(v))] if v is not None else []
    elif is_date_or_none(f.type):
        return [( n, v.strftime('%Y/%m/%d'))] if v is not None else []
    else:
        return []


def traktor_info_flags(at: ATrack) -> str:
    # should we lock it?
    return str(1*0 + 2*0 + 4*1 + 8*1 + 16*int(at.locked) + 32*0 + 64*0)
    # return str(1*0 + 2*0 + 4*1 + 8*1 + 16*0 + 32*0 + 64*0)


def make_tag(name: str, predicate, init: list[tuple[str,str]]):
    def tag_fun(at: ATrack, trans: ATransformation) -> ET.Element:
        fs = list(filter(predicate, fields(at)))
        attrs = dict(reduce(lambda acc, f: acc + tag_attr(at, f),  fs, init))
        trk = ET.Element(name, attrib=attrs)
        return trk

    return tag_fun

########## ENTRY ######################

init_entry_tag = [('MODIFIED_DATE', date.today().strftime('%Y/%m/%d')),
                  ('MODIFIED_TIME', "72880"), # seconds from UTC midnight.
                  ('AUDIO_ID', "")
                  ]
    
entry_tag = make_tag('ENTRY', is_entry_tag_attr, init_entry_tag)

########## LOCATION ######################

def location_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    fpath = at.location.resolve()
    f = fpath.name
    d = traktor_path(fpath.parent)
    vol, volid = location_volume_id(fpath)
    return ET.Element("LOCATION",
                      DIR = d,
                      FILE = f,
                      VOLUME = vol if vol is not None else "",
                      VOLUMEID = volid if volid is not None else "",
                      )

########## ALBUM ######################

album_tag = make_tag('ALBUM', is_album_tag_attr, [])

########## MODIFICATION_INFO ######################

def modification_info_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    return ET.Element("MODIFICATION_INFO", AUTHOR_TYPE="user")

########## INFO ######################

def info_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    return make_tag('INFO', is_info_tag_attr, [('FLAGS', traktor_info_flags(at))])(at, trans)

########## TEMPO ######################

tempo_tag = make_tag('TEMPO', is_tempo_tag_attr, [('BPM_QUALITY', "100.000000")])

########## LOUDNESS ######################

def loudness_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    if at.loudness is None:
        return ET.Element("LOUDNESS")
    else:
        return ET.Element("LOUDNESS",
                          ANALYZED_DB = str(at.loudness.autogain),
                          PERCEIVED_DB = str(at.loudness.autogain),
                          # PEAK_DB = "0.0" # try to force Traktor to recalculate it
                          )
              

########## MUSICAL_KEY ######################

def musical_key_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    t = at.tonality
    if t is not None:
        if len(t) == 2 and t[0].isdigit(): # Camleot
            camleot2classic = inverse_dict(CLASSIC2CAMLEOT_KEY_MAP)
            classic_key = camleot2classic[t]
        elif 1 <= len(t) <= 2 or (2 <= len(t) <= 3 and t[1] in ['#', 'b']): # Abbreviated
            abbrev2classic = inverse_dict(CLASSIC2ABBREV_KEY_MAP)
            classic_key = abbrev2classic[t]
        else: # Classic
            classic_key = t
        k = OPEN_KEY2MUSICAL_KEY_MAP[CLASSIC2OPEN_KEY_MAP[classic_key]]
        return ET.Element("MUSICAL_KEY", VALUE=str(k))
    else:
        raise ValueError(f'musical_key_tag: Can not convert {t} to Open-Key.')

########## CUE_V2 ######################

def cue_v2_markers(m: AMarker) -> ET.Element:
    attrs = {
        'NAME'        : m.name if m.name != '' else 'n.n.',
        'TYPE'        : TRAKTOR_MARKERTYPE_MAP[m.kind],
        'START'       : str(s_to_ms(m.start)),
        'LEN'         : str(s_to_ms(m.end - m.start))  if m.end is not None else "0.0",
        'HOTCUE'      : str(m.index),
        'REPEATS'     : '-1',
        'DISPL_ORDER' : '0'
    }
    return ET.Element('CUE_V2', attrib=attrs)

def cue_v2_beatgrid(bg: ABeatGridBPM) -> ET.Element:
    attrs = {
        'NAME'        : 'Beat Marker',
        'TYPE'        : '4',
        'START'       : str(s_to_ms(bg.position)),
        'LEN'         : '0.0',
        'HOTCUE'      : '-1',
        'REPEATS'     : '-1',
        'DISPL_ORDER' : '0'
    }
    cue = ET.Element('CUE_V2', attrib=attrs)
    grid = ET.Element('GRID', attrib={'BPM' : str(bg.bpm)})
    cue.append(grid)
    return cue

########## MAIN ######################

def to_traktor(at: ATrack, trans: ATransformation) -> ET.Element:
    """Convert an ATrack instance into a Traktor NML ENTRY.
    """
    entry = entry_tag(at, trans)
    # sub-tags
    loc = location_tag(at, trans)
    album = album_tag(at, trans)
    mod_info = modification_info_tag(at, trans)
    info = info_tag(at, trans)
    tempo = tempo_tag(at, trans)
    ldness = loudness_tag(at, trans)
    mkey = musical_key_tag(at, trans)
    for st in [loc, album, mod_info, info, tempo, ldness, mkey]:
        entry.append(st)
    for m in reindex_sdjpro_loops(at.markers, trans):
        entry.append(cue_v2_markers(m))
    for m in at.beatgrid:
        entry.append(cue_v2_beatgrid(m))
    return entry

def to_traktor_playlist(playlist: APlaylist, ofile: Path, trans: ATransformation) -> None:
    """Generate a Traktor playlist NML file.

    Args:
    -----
      playlist: the playlist to convert.
      ofile: output file name.
      trans: information about the source and target format.
    """
    # XML tree root
    nml = ET.Element('NML', VERSION="20")
    root = ET.ElementTree(nml)

    # HEAD sub-element
    ver = trans.target.version[0]
    head = ET.Element('HEAD', COMPANY="www.native-instruments.com", PROGRAM=f"Traktor Pro {ver}")
    nml.append(head)

    # COLLECTION sub-element
    coll = ET.Element('COLLECTION', Entries=str(playlist.entries))
    nml.append(coll)

    # ENTRY SUb-sub-elements
    for at in playlist.tracks:
        new_at = adjust_time(at, trans)
        e = to_traktor(new_at, trans)
        coll.append(e)

    # SETS sub-element
    ## These are related to Remix Sets which are unique to Traktor.
    ## Therefore we don't case about them.
    sets = ET.Element('SETS', ENTRIES="0")
    nml.append(sets)

    # PLAYLIST sub-element
    pl = ET.Element('PLAYLISTS')
    nml.append(pl)
    node = ET.Element('NODE', TYPE="FOLDER", NAME="$ROOT")
    pl.append(node)

    subnodes = ET.Element('SUBNODES', COUNT="1")
    node.append(subnodes)

    node1 = ET.Element('NODE', NAME=playlist.name, TYPE="PLAYLIST")
    subnodes.append(node1)

    pl_list = ET.Element('PLAYLIST', ENTRIES=str(playlist.entries), TYPE="LIST", UUID=str(uuid.uuid4().hex))
    node1.append(pl_list)

    for t in playlist.tracks:
        e = ET.Element('ENTRY')
        e.append(ET.Element('PRIMARYKEY', TYPE="TRACK", KEY=t.location.drive + traktor_path(t.location)))
        pl_list.append(e)

    # INDEXING sub-element
    indexing = ET.Element('INDEXING')
    nml.append(indexing)

    root.write(ofile, "utf-8", True, short_empty_elements=False)
    return None
