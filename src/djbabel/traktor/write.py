from ..types import AMarkerType, ATrack, ATransformation, AMarker, ABeatGridBPM, APlaylist
from ..utils import CLASSIC2ABBREV_KEY_MAP, CLASSIC2CAMLEOT_KEY_MAP, is_str_or_none, is_int_or_none, is_float_or_none, is_date_or_none, CLASSIC2OPEN_KEY_MAP, reindex_sdjpro_loops, s_to_ms
from .utils import traktor_path, location_volume_id

from dataclasses import Field, fields
from datetime import date
from functools import reduce
from pathlib import Path
import xml.etree.ElementTree as ET

import uuid

#######################################################################
# Comments

# Tags and attributes are all UPPERCASE.

## Attributes, tags and sub-tag attributes of an NML ENTRY:

### Attributes
# - MODIFIED_DATE, (required), set to today
# - MODIFIED_TIME, (required), likely seconds from midnight UTC
# - AUDIO_ID, (required), audio fingerprint. Set it to "" to leave the job to Traktor.
# - TITLE, (required)
# - ARTIST, (required)
# - LOCK="1", verify! According to Gemini it's the master lock of the file.

### Sub-tags and their attributes

## LOCATION, (required)
# - DIR
# - FILE
# - VOLUME, volume name, a string, on Win e.g. "C:"
# - VOLUMEID, volume serial or UUID, On Win output of 'vol $VOLUME'

## ALBUM
# - TRACK, track number
# - TITLE

## MODIFICATION_INFO
# - AUTHOR_TYPE="user"

## INFO
# - BITRATE (bps)
# - GENRE
# - LABEL
# - COVERARTID
# - KEY="1m", can use other notations than Open Key (e.g. Camleot, or Classic)
# - PLAYCOUNT
# - PLAYTIME="261"
# - PLAYTIME_FLOAT="260.858765"
# - IMPORT_DATE="2025/7/9"
# - LAST_PLAYED="2025/7/8"
# - RELEASE_DATE="2025/1/1"
# - FLAGS="76", (required), see below for the meaning. 
# - FILESIZE="11746"
# - RATING="4"
# - REMIXER=""

## TEMPO
# - BPM="126.999878", (required to retain BG), the best fit fixed grid BPM
# - BPM_QUALITY="100.000000", (required to retain BG), set to "100.0"

## LOUDNESS
# - PEAK_DB="-0.721318"
# - PERCEIVED_DB="0.000000"
# - ANALYZED_DB="-0.860893"

## MUSICAL_KEY
# - VALUE="21", (required to avoid key re-analisys)

## CUE_V2, (required type 4 to retain BG)
# - NAME, "AutoGrid" for autogenerated TYPE 4 BG, and "Beat Marker" for manual BG
# - DISPL_ORDER="0", apparently always "0"
# - TYPE="4", 4 is SPECIAL for beatgrid and uses the <GRID/> tag
# - START="52.261284" (ms)
# - LEN="0.000000" (ms)
# - REPEATS="-1", -1 is the common value and signifies that a loop repeats indefinitely
# - HOTCUE="-1", 0 based index, -1: not listed in the hot cue GUI
# - <GRID BPM="126.999878"></GRID>

### FLAGS
# Is a 7 bit bitmask with the following meaning:

# 1 (Bit 0): Unplayed/New Track.

# 2 (Bit 1): Beatgrid Locked.

# 4 (Bit 2): Missing/Locate Warning.

# 8 (Bit 3): Analyzed (Key/BPM).

# 16 (Bit 4): Played (at least once).

# 32 (Bit 5): UNCERTAIN: reporter as
# - (most likely) "Has Waveform Data" / "Stripes Generated"
# OR
# - (Less commonly confirmed) Custom Fade In/Out Set.

# 64 (Bit 6): Stem File.

#######################################################################
# Mappings

# Map AMarkerType into the corresponding Rekordbox number
# 4: Grid / Beat Marker / AutoGrid (Used for automatic beatgrid markers)
TRAKTOR_MARKERTYPE_MAP = {
    AMarkerType.CUE : "0",
    AMarkerType.FADE_IN : "2",
    AMarkerType.FADE_OUT : "3",
    AMarkerType.CUE_LOAD : "1",
    AMarkerType.LOOP : "5"
}

# Includes mapping of fields from ATrack to the Traktor Pro 4 NML name of
# only those fields:
# 1) Whose mapping is not a simple conversion to UPPERCASE.
# 2) Are not used. In this case the name maps to None
# The later are mapped via a function.
TRAKTOR_FIELD_NAMES_MAP = {
    # 'title',
    # 'artist',
    # 'composer',
    # 'album', TAG, this is the title
    'grouping' : None,
    # 'genre',
    # 'aformat',
    'size' : 'FILESIZE',
    'total_time' : 'PLAYTIME',
    # 'disc_number', in ALBUM TAG
    'track_number': 'TRACK', # in ALBUM TAG
    # 'release_date',
    'average_bpm' : 'BPM', # in TEMPO TAG
    'date_added' : 'IMPORT_DATE',
    'bit_rate' : 'BITRATE',
    'sample_rate' : None,
    'comments' : 'COMMENT',
    'play_count' : 'PLAYCOUNT',
    # 'rating',
    # 'location', # IS a TAG
    # 'remixer',
    'tonality' : 'KEY',
    # 'label',
    'mix' : None,
    # 'data_source',
    # 'markers',
    # 'beatgrid',
    # 'locked',
    # 'color',
    'trackID' : None,
    # 'loudness'
}

###################################################################
########## Helpers ######################

def make_is_tag_attr_predicate(fns: list[str]):
    """Construct a predicate taking a field and checking if its name is in a list.
    """
    def predicate(f: Field) -> bool:
        n = f.name
        if n in fns:
            return True
        else:
            return False

    return predicate

is_album_tag_attr =  make_is_tag_attr_predicate(['track_number', 'disc_number', 'album'])
is_entry_tag_attr = make_is_tag_attr_predicate(['title', 'artist'])
is_location_tag_attr = make_is_tag_attr_predicate(['location'])
is_tempo_tag_attr = make_is_tag_attr_predicate(['average_bpm'])
is_loudness_tag_attr = make_is_tag_attr_predicate(['loudness'])
is_cue_v2_tag_attr = make_is_tag_attr_predicate(['marker', 'beatgrid'])

def is_info_tag_attr(f: Field) -> bool:
    if not (is_album_tag_attr(f) or is_entry_tag_attr(f) or is_location_tag_attr(f) or is_tempo_tag_attr(f) or is_loudness_tag_attr(f) or is_cue_v2_tag_attr(f)):
        return True
    else:
        return False


def traktor_attr_name(s: str) -> str | None:
    """Convert an ATrack field name (as a string) into the name used by Traktor.
    """
    if s in TRAKTOR_FIELD_NAMES_MAP.keys():
        return TRAKTOR_FIELD_NAMES_MAP[s]
    else:
        return s.upper()


def tag_attr(at: ATrack, f: Field) -> list[tuple[str,str]]:
    v = getattr(at, f.name)
    n = traktor_attr_name(f.name)
    if n is None: # skip unused parameters
        return []
    elif f.name == 'size':
        return [( n, str(int(v/1000)) if v is not None else "0")]
    elif f.name == 'total_time':
        tt = v if v is not None else 0
        return [( n, str(int(tt))), ('PLAYTIME_FLOAT', str(tt))]
    elif is_str_or_none(f.type):
        return [( n, v if v is not None else "")]
    elif is_int_or_none(f.type):
        return [( n, str(v) if v is not None else "0")]
    elif is_float_or_none(f.type):
        return [( n, str(v) if v is not None else "0")]
    elif is_date_or_none(f.type):
        return [( n, v.strftime('%Y/%m/%d') if v is not None else date.today().strftime('%Y/%m/%d'))]
    else:
        return []


def traktor_info_flags(at: ATrack) -> str:
    # should we lock it?
    # return str(1 + 2*int(at.locked) + 4*0 + 8*1 + 16*0 + 32*0 + 64*0)
    return str(1 + 2*0 + 4*0 + 8*1 + 16*0 + 32*0 + 64*0)


def make_tag(name: str, predicate, init: list[tuple[str,str]]):
    def tag_fun(at: ATrack, trans: ATransformation) -> ET.Element:
        fs = list(filter(predicate, fields(at)))
        attrs = dict(reduce(lambda acc, f: acc + tag_attr(at, f),  fs, init))
        trk = ET.Element(name, attrib=attrs)
        return trk

    return tag_fun

########## ENTRY ######################

init_entry_tag = [('MODIFIED_DATE', date.today().strftime('%Y/%m/%d')),
                  ('MODIFIED_TIME', "72880"), # seconds from UTC midnight.
                  ('AUDIO_ID', "")
                  ]
    
entry_tag = make_tag('ENTRY', is_entry_tag_attr, init_entry_tag)

########## LOCATION ######################

def location_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    fpath = at.location.resolve()
    f = fpath.name
    d = traktor_path(fpath.parent)
    vol, volid = location_volume_id(fpath)
    return ET.Element("LOCATION",
                      DIR = d,
                      FILE = f,
                      VOLUME = vol if vol is not None else "",
                      VOLUMEID = volid if volid is not None else "",
                      )

########## ALBUM ######################

album_tag = make_tag('ALBUM', is_album_tag_attr, [])

########## MODIFICATION_INFO ######################

def modification_info_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    return ET.Element("MODIFICATION_INFO", AUTHOR_TYPE="user")

########## INFO ######################

def info_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    return make_tag('INFO', is_info_tag_attr, [('FLAGS', traktor_info_flags(at))])(at, trans)

########## TEMPO ######################

tempo_tag = make_tag('TEMPO', is_tempo_tag_attr, [('BPM_QUALITY', "100.000000")])

########## LOUDNESS ######################

def loudness_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    if at.loudness is None:
        return ET.Element("LOUDNESS")
    else:
        return ET.Element("LOUDNESS",
                          ANALYZED_DB = str(at.loudness.autogain),
                          PERCEIVED_DB = str(at.loudness.autogain),
                          # PEAK_DB = "0.0" # try to force Traktor to recalculate it
                          )
              

########## MUSICAL_KEY ######################

def musical_key_tag(at: ATrack, trans: ATransformation) -> ET.Element:
    t = at.tonality
    if t is not None:
        k = ""
        if len(t) == 2 and t[0].isdigit(): # Camleot
            camleot2classic = {value: key for key, value in CLASSIC2CAMLEOT_KEY_MAP.items()}
            k = CLASSIC2OPEN_KEY_MAP[camleot2classic[t]]
        elif 1 <= len(t) <= 2 or (2 <= len(t) <= 3 and t[1] in ['#', 'b']): # Abbreviated
            abbrev2classic = {value: key for key, value in CLASSIC2ABBREV_KEY_MAP.items()}
            k = CLASSIC2OPEN_KEY_MAP[abbrev2classic[t]]
        else: # Classic
            k = CLASSIC2OPEN_KEY_MAP[t]
        return ET.Element("MUSICAL_KEY", VALUE=k)
    else:
        raise ValueError(f'musical_key_tag: Can not convert {t} to Open-Key.')

########## CUE_V2 ######################

def cue_v2_markers(m: AMarker) -> ET.Element:
    attrs = {
        'NAME'        : m.name if m.name != '' else 'n.n.',
        'TYPE'        : TRAKTOR_MARKERTYPE_MAP[m.kind],
        'START'       : str(s_to_ms(m.start)),
        'LEN'         : str(s_to_ms(m.end - m.start))  if m.end is not None else "0.0",
        'HOTCUE'      : str(m.index),
        'REPEATS'     : '-1',
        'DISPL_ORDER' : '0'
    }
    return ET.Element('CUE_V2', attrib=attrs)

def cue_v2_beatgrid(bg: ABeatGridBPM) -> ET.Element:
    attrs = {
        'NAME'        : 'Beat Marker',
        'TYPE'        : '4',
        'START'       : str(s_to_ms(bg.position)),
        'LEN'         : '0.0',
        'HOTCUE'      : '-1',
        'REPEATS'     : '-1',
        'DISPL_ORDER' : '0'
    }
    cue = ET.Element('CUE_V2', attrib=attrs)
    grid = ET.Element('GRID', attrib={'BPM' : str(bg.bpm)})
    cue.append(grid)
    return cue

########## MAIN ######################

def to_traktor(at: ATrack, trans: ATransformation) -> ET.Element:
    """Convert an ATrack instance into a Traktor NML ENTRY.
    """
    entry = entry_tag(at, trans)
    # sub-tags
    loc = location_tag(at, trans)
    album = album_tag(at, trans)
    mod_info = modification_info_tag(at, trans)
    info = info_tag(at, trans)
    tempo = tempo_tag(at, trans)
    ldness = loudness_tag(at, trans)
    mkey = musical_key_tag(at, trans)
    for st in [loc, album, mod_info, info, tempo, ldness, mkey]:
        entry.append(st)
    # new_at = adjust_time(at, trans)
    for m in reindex_sdjpro_loops(at.markers, trans):
        entry.append(cue_v2_markers(m))
    for m in at.beatgrid:
        entry.append(cue_v2_beatgrid(m))
    return entry

def to_traktor_playlist(playlist: APlaylist, ofile: Path, trans: ATransformation) -> None:
    """Generate a Traktor playlist NML file.

    Args:
    -----
      playlist: the playlist to convert.
      ofile: output file name.
      trans: information about the source and target format.
    """
    # XML tree root
    nml = ET.Element('NML', VERSION="20")
    root = ET.ElementTree(nml)

    # HEAD sub-element
    ver = trans.target.version[0]
    head = ET.Element('HEAD', COMPANY="www.native-instruments.com", PROGRAM=f"Traktor Pro {ver}")
    nml.append(head)

    # COLLECTION sub-element
    coll = ET.Element('COLLECTION', Entries=str(playlist.entries))
    nml.append(coll)

    # ENTRY SUb-sub-elements
    for at in playlist.tracks:
        e = to_traktor(at, trans)
        coll.append(e)

    # SETS sub-element
    ## These are related to Remix Sets which are unique to Traktor.
    ## Therefore we don't case about them.
    sets = ET.Element('SETS', ENTRIES="0")
    nml.append(sets)

    # PLAYLIST sub-element
    pl = ET.Element('PLAYLISTS')
    nml.append(pl)
    node = ET.Element('NODE', TYPE="FOLDER", NAME="$ROOT")
    pl.append(node)

    subnodes = ET.Element('SUBNODES', COUNT="1")
    node.append(subnodes)

    node1 = ET.Element('NODE', NAME=playlist.name, TYPE="PLAYLIST")
    subnodes.append(node1)

    pl_list = ET.Element('PLAYLIST', ENTRIES=str(playlist.entries), TYPE="LIST", UUID=str(uuid.uuid4().hex))
    node1.append(pl_list)

    for t in playlist.tracks:
        e = ET.Element('ENTRY')
        e.append(ET.Element('PRIMARYKEY', TYPE="TRACK", KEY=t.location.drive + traktor_path(t.location)))
        pl_list.append(e)

    # INDEXING sub-element
    indexing = ET.Element('INDEXING')
    nml.append(indexing)

    root.write(ofile, "utf-8", True, short_empty_elements=False)
    return None
